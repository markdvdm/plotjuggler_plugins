/// This file was autogenerated by elroy_common_msg, do not modify
/// @copyright Copyright 2022 Elroy Air Inc. All rights reserved.
/// @author elroy_common_msg autogen

#ifndef {{ struct.metadata.file.header.include_guard }}
#define {{ struct.metadata.file.header.include_guard }}

#include <cstdint>
#include <cstddef>
#include <cassert>
#include <algorithm>
#include <iterator>
#include <variant>
#include <map>

{% for include in struct.metadata.file.header.includes %}
#include "{{ include }}"
{% endfor %}
#include "msg_packing_util/msg_packing_util.h"

{% if "namespace" in struct %}
namespace elroy_common_msg::{{ struct.namespace }} {
{% else %}
namespace elroy_common_msg {
{% endif %}
struct {{ struct.name }} {% if struct.inherit is defined %}: public {{ struct.inherit.name }} {% endif %} {
{% if not((struct.inherit is not defined) and (not((struct.members is defined) and (struct.members) and (0 < struct.members|length)))) %}
  /// @brief default constructor
  {{ struct.name -}}()
  {{- " : " + struct.inherit.name + "()" if struct.inherit is defined }} {}
{% endif %}

  /// @brief compile-time constructor
  /// @note useful for literals
  constexpr {{ struct.name }}(
  {%- if ((struct.inherit is defined) and (struct.inherit.name != "BusObjectStruct")) -%}
    const {{ struct.inherit.name }}& parent{{ ", " if (struct.members is defined) and (struct.members) and (0 < struct.members|length) }}
  {%- endif -%}
  {%- if struct.members is defined %}
    {% for member in struct.metadata.members %}
      {{- "const " + member.type + " " + member.name }}{% if member.array_len is defined %}[{{ member.array_len }}]{% endif %}{{ ", " if not loop.last }}
    {%- endfor -%}
  {%- endif -%} )
  {% if ((struct.inherit is defined) and (struct.inherit.name != "BusObjectStruct")) %}
    {{- "      : " + struct.inherit.name + "(parent, {})" -}}
  {%- endif -%}
  {% if struct.members is defined %}
    {% for member in struct.metadata.members %}
      {% if loop.first %}
        {% if ((struct.inherit is defined) and (struct.inherit.name != "BusObjectStruct")) %}
          {{- "," }}
        {% else %}
          {{- "      : " -}}
        {%- endif -%}
      {%- else -%}
        {{- "," }}
      {% endif %}
      {% if member.array_len is not defined %}
        {% if loop.first and struct.inherit is not defined %}
        {{- member.name + "_{ " + member.name}} {%- if member.type in struct_types %}, {} {%- endif -%} {{- " }" -}}
        {% else %}
        {{ member.name + "_{ " + member.name}} {%- if member.type in struct_types %}, {} {%- endif -%} {{- " }" -}}
        {% endif %}
      {% else %}
        {% if member.type in struct_types %}
        {{- member.name -}}_{
        {% else %}
        {{ member.name -}}_{
        {% endif %}
        {% for index in range(member.array_len) %}
          {% if member.type in struct_types %}
          {{ "{ " + member.name + "[" + index|string + "], {} }" -}}
          {% else %}
          {{ member.name + "[" + index|string + "]" -}}
          {% endif %}
          {% if not loop.last %},{% endif %}

        {% endfor %}
        {{ "}" -}}

      {%- endif -%}
    {%- endfor -%}
  {%- endif %} {}

  /// @brief copy constructor
  /// @note allows for Astruct(Bstruct)
  {{ struct.name }}(const {{ struct.name }} & src)
  {% if struct.inherit is defined %}
    {{- "      : " + struct.inherit.name + "(src)" -}}
  {% endif %}
  {%- if struct.members is defined -%}
    {% for member in struct.metadata.members %}
      {% if member.array_len is not defined %}
        {% if loop.first %}
          {% if struct.inherit is defined %}
            {{- "," }}
          {% else %}
            {{- "      : " -}}
          {%- endif -%}
        {%- else -%}
          {{- "," }}
        {% endif %}
        {% if loop.first and struct.inherit is not defined %}
          {{- member.name + "_{ src." + member.name + "_ }" -}}
        {% else %}
          {{- "        " + member.name + "_{ src." + member.name + "_ }" -}}
        {% endif %}
      {% endif %}
    {% endfor %}
  {% endif %} {
    {% if ((struct.members is defined) and (struct.members) and (0 < struct.members|length)) %}
      {% for member in struct.metadata.members %}
        {% if member.array_len is defined %}
    // deepcopy {{ member.name }}_
    for (int i = 0; i < {{member.array_len}}; i++) {
      {{ member.name }}_[i] = src.{{ member.name }}_[i];
    }
        {% endif %}
      {% endfor %}
    {% elif (struct.inherit is not defined) %}
    (void)src;
    {% endif %}
  }

  /// @brief compile-time copy constructor
  /// @note allows for Astruct(Bstruct); the unnamed argument is a hack used for overloading.
  constexpr {{ struct.name }}(const {{ struct.name }} & src, const void*)
  {% if struct.inherit is defined %}
    {{- "      : " + struct.inherit.name + "(src, {})" -}}
  {%- endif -%}
  {% if struct.members is defined %}
    {% for member in struct.metadata.members %}
      {% if loop.first %}
        {% if struct.inherit is defined%}
          {{- "," }}
        {% else %}
          {{- "      : " -}}
        {%- endif -%}
      {% else %}
        {{- "," }}
      {% endif %}
      {% if member.array_len is not defined %}
        {% if loop.first and struct.inherit is not defined %}
        {{- member.name + "_{ src." + member.name + "_"}} {%- if member.type in struct_types -%}, {} {%- endif -%} {{- " }" -}}
        {% else %}
        {{ member.name + "_{ src." + member.name + "_"}} {%- if member.type in struct_types -%}, {} {%- endif -%} {{- " }" -}}
        {% endif %}
      {% else %}
        {% if member.type in struct_types %}
        {{- member.name -}}_{
        {% else %}
        {{ member.name -}}_{
        {% endif %}
        {% for index in range(member.array_len) %}
          {% if member.type in struct_types %}
          {{ "{ src." + member.name + "_[" + index|string + "], {} }" -}}
          {% else %}
          {{ "src." + member.name + "_[" + index|string + "]" -}}
          {% endif %}
          {% if not loop.last %},{% endif %}

        {% endfor %}
        {{ "}" -}}

      {%- endif -%}
    {%- endfor -%}
  {%- endif %} { {{- "(void)src;" if ((struct.inherit is not defined) and not((struct.members is defined) and (struct.members) and (0 < struct.members|length))) -}} }

  /// @brief copy assignment operator
  /// @note allows for Astruct = Bstruct
  {{ struct.name }}& operator=(const {{ struct.name }} & src)
  {
    {% if struct.inherit is defined %}
    this->{{ struct.inherit.name }}::operator=(src);
    {% else %}
    (void)src;
    {% endif %}
    {% if struct.members is defined %}
    {% for member in struct.metadata.members %}
    {% if member.array_len is not defined %}
    {{ member.name }}_ = src.{{member.name}}_;
    {% endif %}
    {% endfor %}
  {% endif %}
    {% if struct.members is defined %}
      {% for member in struct.metadata.members %}
        {% if member.array_len is defined %}
    // deepcopy {{ member.name }}_
    for (int i = 0; i < {{member.array_len}}; i++) {
      {{ member.name }}_[i] = src.{{ member.name }}_[i];
    }
        {% endif %}
      {% endfor %}
    {% else %}
    (void)src;
    {% endif %}

    return *this;
  }

  /// @brief Returns the encoded size of this message
  /// @return the encoded size of this message
  virtual size_t GetPackedSize(void) const noexcept {
    return {% if struct.inherit is defined -%}{{ struct.inherit.name }}::GetPackedSize()
    {%- endif -%}
    {% if (struct.members is defined) and (struct.members) and (0 < struct.members|length) %}
      {%- if struct.inherit is defined %}
      {{- " +"}}
      {% endif %}
      {% for member in struct.metadata.members %}
        {% if member.is_struct is defined %}
      {{ member.name }}_{{ "[0]" if member.array_len is defined }}.GetPackedSize()
        {%- if member.array_len is defined %} * {{member.array_len}}{% endif -%}
        {%- else %}
      sizeof({{ member.name }}_)
        {%- endif -%}
      {%- if not loop.last %} +
        {% else %};
        {% endif %}
      {% endfor -%}
    {% else -%}
      {%- if struct.inherit is defined %};
      {% else %}0;
      {% endif %}
    {% endif %}
  }

  virtual size_t Pack(uint8_t* dest, size_t dest_size) const noexcept {
    assert(dest_size >= GetPackedSize());
    size_t bytes_packed = 0;
    {% if struct.inherit is defined %}
    bytes_packed += {{ struct.inherit.name }}::Pack(&dest[bytes_packed], dest_size);
    {% endif %}
    {% if struct.members is defined %}
      {% for member in struct.metadata.members %}
          {% if member.array_len is defined %}
            {% if member.is_struct is defined %}
    for (int i = 0; i < {{ member.array_len }}; i++) {
      bytes_packed += {{ member.name }}_[i].Pack(&dest[bytes_packed], dest_size - bytes_packed);
    }
            {% else %}
    for (int i = 0; i < {{ member.array_len }}; i++) {
      bytes_packed += elroy_common_msg::MsgPackingUtil::Pack(&dest[bytes_packed], {{ member.name }}_[i]);
    }
            {% endif %}
          {% else %}
            {% if member.is_struct is defined %}
    bytes_packed += {{ member.name }}_.Pack(&dest[bytes_packed], dest_size - bytes_packed);
            {% else %}
    bytes_packed += elroy_common_msg::MsgPackingUtil::Pack(&dest[bytes_packed], {{ member.name }}_);
            {% endif %}
          {% endif %}
      {% endfor %}
    {% endif %}
    (void)dest;
    (void)dest_size;
    return bytes_packed;
  }

  virtual size_t Unpack(const uint8_t* src, size_t src_size) noexcept {
    assert(src_size >= GetPackedSize());
    size_t bytes_unpacked = 0;
    {% if struct.inherit is defined %}
    bytes_unpacked += {{ struct.inherit.name }}::Unpack(&src[bytes_unpacked], src_size);
    {% endif %}
    {% if struct.members is defined %}
      {% for member in struct.metadata.members %}
          {% if member.array_len is defined %}
            {% if member.is_struct is defined %}
    for (int i = 0; i < {{member.array_len}}; i++) {
      bytes_unpacked += {{ member.name }}_[i].Unpack(&src[bytes_unpacked], src_size - bytes_unpacked);
    }
            {% else %}
    for (int i = 0; i < {{member.array_len}}; i++) {
      bytes_unpacked += elroy_common_msg::MsgPackingUtil::Unpack({{ member.name }}_[i], &src[bytes_unpacked]);
    }
            {% endif %}
          {% else %}
            {% if member.is_struct is defined %}
    bytes_unpacked += {{member.name}}_.Unpack(&src[bytes_unpacked], src_size - bytes_unpacked);
            {% else %}
    bytes_unpacked += elroy_common_msg::MsgPackingUtil::Unpack({{ member.name }}_, &src[bytes_unpacked]);
            {% endif %}
        {% endif %}
      {% endfor %}
    {% endif %}
    (void)src;
    (void)src_size;
    return bytes_unpacked;
  }

  /// @brief Read this object as a map. If the type of a child is std::is_base_of<BusObject, typeof(child)>, then 
  /// recursively call the ReadAsMap.
  /// @param[in/out] destination map to write data to
  /// @param prefix Prefix to add to the beginning of all map keys for this object
  /// @param delim Delimiter used to signify levels of nesting in a message
  bool ReadAsMap(std::unordered_map<std::string, std::variant<std::string, double, bool>> &map, const std::string& prefix = "", const std::string& delim = "."){
    bool res = true;
    {% if struct.members is defined %}
      {% for member in struct.metadata.members -%}
        {% if member.array_len is defined %}
          {% for index in range(member.array_len) %}
            {% if member.is_enum is defined %}
    map[prefix + delim + "{{member.name}}_str_[{{index}}]"] = EnumToString({{member.name}}_[{{index}}]);
    map[prefix + delim + "{{member.name}}_[{{index}}]"] = static_cast<double>(EnumToArrayIndex({{member.name}}_[{{index}}]));
            {% elif member.type in struct_types %}
    res &= {{member.name}}_[{{index}}].ReadAsMap(map, prefix + delim + "{{member.name}}_[{{index}}]", delim);        
            {% elif member.is_struct is defined %}
    res &= {{member.name}}_[{{index}}].ReadAsMap(map, prefix + delim + "{{member.name}}_[{{index}}]", delim);
            {% elif member.type in ["uint32_t", "uint8_t", "float", "uint16_t", "int16_t", "int32_t", "double", "uint64_t","int64_t", "size_t"] %}
    map[prefix + delim + "{{member.name}}"] = static_cast<double>({{member.name}}_[{{index}}]);
            {% else %}
    map[prefix + delim + "{{member.name}}_[{{index}}]"] = {{member.name}}_[{{index}}];
            {% endif %}
          {% endfor %}
        {% elif member.type in ["uint32_t", "uint8_t", "float", "uint16_t", "int16_t", "int32_t", "double", "uint64_t","int64_t", "size_t"] %}
    map[prefix + delim + "{{member.name}}"] = static_cast<double>({{member.name}}_);
        {% elif member.type in ["string"] %}
    map[prefix + delim + "{{member.name}}"] = {{member.name}}_;
        {% elif member.type in ["bool"] %}
    map[prefix + delim + "{{member.name}}"] = {{member.name}}_;
        {% elif member.is_struct is defined%}
    res &= {{member.name}}_.ReadAsMap(map, prefix + delim + "{{member.name}}", delim);
        {% elif member.is_enum is defined %}
    map[prefix + delim + "{{member.name}}_str"] = EnumToString({{member.name}}_);
    map[prefix + delim + "{{member.name}}"] = static_cast<double>(EnumToArrayIndex({{member.name}}_));
        {% else %}
    throw("JINJA_ERROR: structs_header.jinja2 was unable to generate a Map for {{member.name}}");
    {{member}}
        {% endif %} 
      {%- endfor %}
    {% endif %}
    return res;
  }


  {% if struct.members is defined %}
  /// {{ struct.name }} member data
  {% for member in struct.metadata.members %}
  {{ member.type }} {{ member.name }}_{% if member.array_len is defined %}[{{ member.array_len }}]{% endif %}
      {% if member.default is defined -%} {{- " " -}} = {{-" "-}}
        {%- if member.array_len is defined %}
          {% set len = member.array_len | int %}
            {{- "{"}}
            {%- for i in range(0, len) -%}
              {{- member.default -}}
              {{- "," if not loop.last -}}
            {% endfor -%}
            {{- "}"}};
        {% else -%}
          { {{ member.default if (member.type != "bool") else member.default|string|lower }} };
        {% endif -%}
      {% else %}
       {{- " = {};" }}
      {% endif %}
  {% endfor %}
  {% else %}
  /// {{ struct.name }} has no member data
  {% endif %}
};

inline bool operator==(const {{ struct.name }}& lhs, const {{ struct.name }}& rhs) {
  {% if struct.inherit is defined %}
    return (static_cast<{{ struct.inherit.name }}>(lhs) == static_cast<{{ struct.inherit.name }}>(rhs)) {{- "&&" if (struct.members is defined) and (struct.members) and (0 < struct.members|length) -}}
  {% elif not((struct.members is defined) and (struct.members) and (0 < struct.members|length)) %}
    (void)lhs;
    (void)rhs;
    return true
  {% else %}
    return 
  {% endif %}
  {% for member in struct.metadata.members %}
      {% if member.array_len is not defined %}
        {% if member.type in ['float', 'double'] %}
          (std::abs(lhs.{{ member.name }}_ - rhs.{{ member.name }}_) < 0.00001)
        {% else %}
          (lhs.{{ member.name }}_ == rhs.{{ member.name }}_)
        {% endif %}
      {% else %}
        std::equal(std::begin(lhs.{{ member.name }}_), std::end(lhs.{{ member.name }}_), std::begin(rhs.{{ member.name }}_))
      {%- endif -%}
    {{- "&&" if not loop.last -}}
  {% endfor %}
  ;
}

inline bool operator!=(const {{ struct.name }}& lhs, const {{ struct.name }}& rhs) {
  return !(lhs == rhs);
}


}  // namespace {% if "namespace" in struct %} {{struct.namespace}} {% else %}elroy_common_msg {% endif %}

#endif   //  {{ struct.metadata.file.header.include_guard }}
{{ "" }}
