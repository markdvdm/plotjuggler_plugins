/// This file was autogenerated by elroy_common_msg, do not modify
/// @copyright Copyright 2022 Elroy Air Inc. All rights reserved.
/// @author elroy_common_msg autogen

#ifndef INCLUDE_ELROY_COMMON_MSG_CRC_C_CRC_CALCULATOR_H_
#define INCLUDE_ELROY_COMMON_MSG_CRC_C_CRC_CALCULATOR_H_

#include <cstddef>
#include <cstdint>

#include "msg_packing_util/msg_packing_util.h"

namespace elroy_common_msg {

class CCrcCalculator {
 public:
  /// @brief remove constructors/destructor, static class
  CCrcCalculator(void) = delete;
  CCrcCalculator(const CCrcCalculator &that) = delete;
  CCrcCalculator(const CCrcCalculator &&that) = delete;
  virtual ~CCrcCalculator(void) = delete;

  /// @brief calculates the crc of buf from index 0 to len-4
  /// @note CRC calculation is a standard crc32 lookup table per:
  ///       https://create.stephan-brumme.com/crc32/#sarwate
  /// @param[in] buf the buffer
  /// @param[in] len the buffer length
  /// @param[in] previous_crc previous crc if part of a continuous crc
  ///            calculation. Defaults to 0xFFFFFFFF
  /// @return the crc of buf from index 0 to len - 4
  static uint32_t CalculateCrc(const uint8_t *buf, const size_t len, uint32_t previous_crc = 0xFFFFFFFFU) {
    uint32_t crc = previous_crc;
    const size_t len_to_crc = len - sizeof(uint32_t);
    for (size_t i = 0; i < len_to_crc; i++) {
      uint8_t pos = static_cast<uint8_t>(crc >> 24) ^ buf[i];
      crc = (crc << 8U) ^ kCrc32LookupTable_[pos];
    }

    return crc ^ 0xFFFFFFFFU;
  }

  /// @brief calculates the CRC of buf, using CalculateCrc, and compares
  ///        it with the last 4 bytes of the buf
  /// @param[in] buf the buffer
  /// @param[in] len the buffer length
  /// @return true if the calculated CRC matches the CRC in buf
  static bool CalculateAndCompareCrc(const uint8_t *buf, const size_t len) {
    (void)buf;
    (void)len;
    const uint32_t crc = CalculateCrc(buf, len);
    uint32_t expected_crc;
    const size_t bytes_unpacked =
        elroy_common_msg::MsgPackingUtil::Unpack(expected_crc, &buf[len - static_cast<size_t>(4)]);
    (void)bytes_unpacked;
    return crc == expected_crc;
  }

  /// @brief this table was generated with elroy_common_msg/scripts/crc_util.py via:
  ///        crc_util.py --poly 0X1F1922815 --gen-table
  /// @note crc_util defaults to use crcmod lookup table generation
  /// @note crc32 lookup table for polynomial 0x1F1922815
  static constexpr uint32_t kCrc32LookupTable_[256] = {
      0x00000000, 0xF1922815, 0x12B6783F, 0xE324502A, 0x256CF07E, 0xD4FED86B, 0x37DA8841, 0xC648A054, 0x4AD9E0FC,
      0xBB4BC8E9, 0x586F98C3, 0xA9FDB0D6, 0x6FB51082, 0x9E273897, 0x7D0368BD, 0x8C9140A8, 0x95B3C1F8, 0x6421E9ED,
      0x8705B9C7, 0x769791D2, 0xB0DF3186, 0x414D1993, 0xA26949B9, 0x53FB61AC, 0xDF6A2104, 0x2EF80911, 0xCDDC593B,
      0x3C4E712E, 0xFA06D17A, 0x0B94F96F, 0xE8B0A945, 0x19228150, 0xDAF5ABE5, 0x2B6783F0, 0xC843D3DA, 0x39D1FBCF,
      0xFF995B9B, 0x0E0B738E, 0xED2F23A4, 0x1CBD0BB1, 0x902C4B19, 0x61BE630C, 0x829A3326, 0x73081B33, 0xB540BB67,
      0x44D29372, 0xA7F6C358, 0x5664EB4D, 0x4F466A1D, 0xBED44208, 0x5DF01222, 0xAC623A37, 0x6A2A9A63, 0x9BB8B276,
      0x789CE25C, 0x890ECA49, 0x059F8AE1, 0xF40DA2F4, 0x1729F2DE, 0xE6BBDACB, 0x20F37A9F, 0xD161528A, 0x324502A0,
      0xC3D72AB5, 0x44797FDF, 0xB5EB57CA, 0x56CF07E0, 0xA75D2FF5, 0x61158FA1, 0x9087A7B4, 0x73A3F79E, 0x8231DF8B,
      0x0EA09F23, 0xFF32B736, 0x1C16E71C, 0xED84CF09, 0x2BCC6F5D, 0xDA5E4748, 0x397A1762, 0xC8E83F77, 0xD1CABE27,
      0x20589632, 0xC37CC618, 0x32EEEE0D, 0xF4A64E59, 0x0534664C, 0xE6103666, 0x17821E73, 0x9B135EDB, 0x6A8176CE,
      0x89A526E4, 0x78370EF1, 0xBE7FAEA5, 0x4FED86B0, 0xACC9D69A, 0x5D5BFE8F, 0x9E8CD43A, 0x6F1EFC2F, 0x8C3AAC05,
      0x7DA88410, 0xBBE02444, 0x4A720C51, 0xA9565C7B, 0x58C4746E, 0xD45534C6, 0x25C71CD3, 0xC6E34CF9, 0x377164EC,
      0xF139C4B8, 0x00ABECAD, 0xE38FBC87, 0x121D9492, 0x0B3F15C2, 0xFAAD3DD7, 0x19896DFD, 0xE81B45E8, 0x2E53E5BC,
      0xDFC1CDA9, 0x3CE59D83, 0xCD77B596, 0x41E6F53E, 0xB074DD2B, 0x53508D01, 0xA2C2A514, 0x648A0540, 0x95182D55,
      0x763C7D7F, 0x87AE556A, 0x88F2FFBE, 0x7960D7AB, 0x9A448781, 0x6BD6AF94, 0xAD9E0FC0, 0x5C0C27D5, 0xBF2877FF,
      0x4EBA5FEA, 0xC22B1F42, 0x33B93757, 0xD09D677D, 0x210F4F68, 0xE747EF3C, 0x16D5C729, 0xF5F19703, 0x0463BF16,
      0x1D413E46, 0xECD31653, 0x0FF74679, 0xFE656E6C, 0x382DCE38, 0xC9BFE62D, 0x2A9BB607, 0xDB099E12, 0x5798DEBA,
      0xA60AF6AF, 0x452EA685, 0xB4BC8E90, 0x72F42EC4, 0x836606D1, 0x604256FB, 0x91D07EEE, 0x5207545B, 0xA3957C4E,
      0x40B12C64, 0xB1230471, 0x776BA425, 0x86F98C30, 0x65DDDC1A, 0x944FF40F, 0x18DEB4A7, 0xE94C9CB2, 0x0A68CC98,
      0xFBFAE48D, 0x3DB244D9, 0xCC206CCC, 0x2F043CE6, 0xDE9614F3, 0xC7B495A3, 0x3626BDB6, 0xD502ED9C, 0x2490C589,
      0xE2D865DD, 0x134A4DC8, 0xF06E1DE2, 0x01FC35F7, 0x8D6D755F, 0x7CFF5D4A, 0x9FDB0D60, 0x6E492575, 0xA8018521,
      0x5993AD34, 0xBAB7FD1E, 0x4B25D50B, 0xCC8B8061, 0x3D19A874, 0xDE3DF85E, 0x2FAFD04B, 0xE9E7701F, 0x1875580A,
      0xFB510820, 0x0AC32035, 0x8652609D, 0x77C04888, 0x94E418A2, 0x657630B7, 0xA33E90E3, 0x52ACB8F6, 0xB188E8DC,
      0x401AC0C9, 0x59384199, 0xA8AA698C, 0x4B8E39A6, 0xBA1C11B3, 0x7C54B1E7, 0x8DC699F2, 0x6EE2C9D8, 0x9F70E1CD,
      0x13E1A165, 0xE2738970, 0x0157D95A, 0xF0C5F14F, 0x368D511B, 0xC71F790E, 0x243B2924, 0xD5A90131, 0x167E2B84,
      0xE7EC0391, 0x04C853BB, 0xF55A7BAE, 0x3312DBFA, 0xC280F3EF, 0x21A4A3C5, 0xD0368BD0, 0x5CA7CB78, 0xAD35E36D,
      0x4E11B347, 0xBF839B52, 0x79CB3B06, 0x88591313, 0x6B7D4339, 0x9AEF6B2C, 0x83CDEA7C, 0x725FC269, 0x917B9243,
      0x60E9BA56, 0xA6A11A02, 0x57333217, 0xB417623D, 0x45854A28, 0xC9140A80, 0x38862295, 0xDBA272BF, 0x2A305AAA,
      0xEC78FAFE, 0x1DEAD2EB, 0xFECE82C1, 0x0F5CAAD4};
};

}  // namespace elroy_common_msg

#endif  // INCLUDE_ELROY_COMMON_MSG_CRC_C_CRC_CALCULATOR_H_
