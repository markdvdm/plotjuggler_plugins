/// @copyright Copyright 2022 Elroy Air Inc. All rights reserved.
/// @author elroy_common_msg autogeneration

#include "elroy_common_msg/msg_handling/msg_decoder.h"
#include "gtest/gtest.h"

/// @brief TestHandler class overrides the base message
class TestHandler : public elroy_common_msg::IMsgHandler {
 public:
  /// @brief Empty Constructor - nothing to do
  TestHandler() : IMsgHandler() {}

  /// @brief Default Deconstructor
  virtual ~TestHandler() = default;

  void Handle(const elroy_common_msg::BusObjectMessage &msg) noexcept override {
    uint8_t message_id = static_cast<uint8_t>(msg.GetMessageId());
    message_handle_counter_[message_id]++;
  }

  void ClearFlags(void) {
    for (uint32_t i = 0; i < kMessageHandleCounterArraySize_; i++) {
      message_handle_counter_[i] = static_cast<uint32_t>(0);
    }
  }

  /// handle counter array is index based on the message ID
  static constexpr uint32_t kMessageHandleCounterArraySize_ = static_cast<uint32_t>(elroy_common_msg::MessageId::Count);
  uint32_t message_handle_counter_[kMessageHandleCounterArraySize_] = {0};
};

/// @brief this test validates the CRC calculator
TEST(MsgHandlingUt, CrcValidation) {

  /**
    buf was generated by serializing ActuatorCommandsMessage with
    the following:
    elroy_common_msg::ActuatorCommands cmds;
      cmds.thruster_cmds_a_.fp_cmds_[0] = 100.f;
      cmds.thruster_cmds_a_.fp_cmds_[1] = 101.f;
      cmds.thruster_cmds_a_.fp_cmds_[2] = 200.f;
      cmds.thruster_cmds_a_.fp_cmds_[3] = 210.f;
      cmds.thruster_cmds_a_.vl_cmds_[0] = 30.f;
      cmds.thruster_cmds_a_.vl_cmds_[1] = 20.f;
      cmds.thruster_cmds_a_.vl_cmds_[2] = 33.f;
      cmds.thruster_cmds_a_.vl_cmds_[3] = 56.f;
      cmds.thruster_cmds_a_.vl_cmds_[4] = 29.5f;
      cmds.thruster_cmds_a_.vl_cmds_[5] = 31.1f;
      cmds.thruster_cmds_a_.vl_cmds_[6] = 32.f;
      cmds.thruster_cmds_a_.vl_cmds_[7] = 35.f;
      cmds.cs_servo_cmds_deg_.cmds_[0] = 1.f;
      cmds.cs_servo_cmds_deg_.cmds_[1] = 1.2f;
      cmds.cs_servo_cmds_deg_.cmds_[2] = 18.5f;
      cmds.cs_servo_cmds_deg_.cmds_[3] = 11.9f;
      cmds.cs_servo_cmds_deg_.cmds_[4] = 12.5f;
      cmds.cs_servo_cmds_deg_.cmds_[5] = 10.2f;
      cmds.cs_servo_cmds_deg_.cmds_[6] = 14.f;
      cmds.cs_servo_cmds_deg_.cmds_[7] = 16.f;
      cmds.cs_servo_cmds_deg_.cmds_[8] = 17.f;
      cmds.cs_servo_cmds_deg_.cmds_[9] = 18.f;
      cmds.cs_servo_cmds_deg_.cmds_[10] = 19.f;
    
    and utilizing allocortech::time::GetTime().Milliseconds();

    then printed. This test buffer may not reflect the
    current ActuatorCommandsMessage or ActuatorCommands struct
  **/
  uint8_t buf[] = {
    0x0E, 0x00, 0x90, 0x9E, 0x12, 0x26, 0x00, 0x00, 0xF0, 0x41,
    0x00, 0x00, 0xA0, 0x41, 0x00, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x60, 0x42, 0x00, 0x00, 0xEC, 0x41, 0xCD, 0xCC, 0xF8, 0x41,
    0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x0C, 0x42, 0x00, 0x00,
    0xC8, 0x42, 0x00, 0x00, 0xCA, 0x42, 0x00, 0x00, 0x48, 0x43,
    0x00, 0x00, 0x52, 0x43, 0x00, 0x00, 0x80, 0x3F, 0x9A, 0x99,
    0x99, 0x3F, 0x00, 0x00, 0x94, 0x41, 0x66, 0x66, 0x3E, 0x41,
    0x00, 0x00, 0x48, 0x41, 0x33, 0x33, 0x23, 0x41, 0x00, 0x00,
    0x60, 0x41, 0x00, 0x00, 0x80, 0x41, 0x00, 0x00, 0x88, 0x41,
    0x00, 0x00, 0x90, 0x41, 0x00, 0x00, 0x98, 0x41, 0x07, 0x2F,
    0xF9, 0x1C};
  uint32_t expected_crc = 0x1CF92F07;
  size_t buf_len = 102;

  EXPECT_EQ(expected_crc, elroy_common_msg::CCrcCalculator::CalculateCrc(buf, buf_len));
  EXPECT_EQ(true, elroy_common_msg::CCrcCalculator::CalculateAndCompareCrc(buf, buf_len));

  // flip a bit 
  buf[5]++;

  EXPECT_NE(expected_crc, elroy_common_msg::CCrcCalculator::CalculateCrc(buf, buf_len));
  EXPECT_EQ(false, elroy_common_msg::CCrcCalculator::CalculateAndCompareCrc(buf, buf_len));
}

/// @brief Tests are generated per enum as follows:
///        <Enum>GoodDecodeAandHandle:
///         1. Insantiates a MsgDecoder, TestHandler
///         2. Creates a msg
///         3. Packs the msg into a buffer
///         4. Validates GetPackedSize() == GetPackedSizeWithoutCrc() + sizeof(uint32_t)
///         5. Validates PackWithoutCrc() is the same as Pack with no data in CRC spots
///            a. Validates PackWithoutCrc() returns GetPackedSize() - sizeof(uint32_t)
///         6. Unpacks a message
///         7. Validates UnpackWithoutCrc() results in latest_unpacked_crc_ is 0
///             a. Validates UnpackWithoutCrc() returns GetPackedSize() - sizeof(uint32_t)
///         8. Decodes 
///             a. expected elroy_common_msg::MessageDecoderResult::SuccessfullyDecoded
///         9. Ensures bytes_processed = GetPackedSize() (kBufLen)
///         10. Checks that respective TestHandler bool is true
///         11. Checks that all other TestHandler bools are false
///        <Enum>BadDecode:
///         1. Insantiates a MsgDecoder, TestHandler
///         2. Creates a msg
///         3. Packes the msg into a buffer
///         4. Validates Message ID is the in the first two bytes
///         5. Decodes with only 1 byte
///             a. Expect processed bytes = 0
///             b.l expectes elroy_common_msg::MessageDecoderResult::NotEnoughBytesToDecodeMessageId
///         6. Decodes with only 2 bytes (message ID)
///             a. Expect processed bytes = 2
///         7. Decodes < kBufLen
///             a. Expects processd bytes = 2
///             b. Expectes elroy_common_msg::MessageDecoderResult::BufLenIsLessThanPackedSize 
///         8. Decode w/ good packet, invalid CRC
///             a. expect elroy_common_msg::MessageDecoderResult::InvalidCrc
///         9. Decode w/ invalid MSG Id
///             a. expect elroy_common_msg::MessageDecoderResult::InvalidMessageId 
///         8. For 5, 6, 7, also expect handler bool to be false 
///         9. Ensure good decode, for completeness
///             a. expected elroy_common_msg::MessageDecoderResult::SuccessfullyDecoded
{% for msg in msg_handling.msgs %}
  {%- if msg.class.namespace is defined %} {% set namespace = "elroy_common_msg::" ~ msg.class.namespace %}
  {% else %}{% set namespace = "elroy_common_msg" %}
  {% endif %}
  {% set msg_uut = msg.class.name %}
TEST(MsgHandlingUt, {{msg_uut}}GoodDecodeAndHandle) {

  // 1.
  TestHandler handler;
  elroy_common_msg::MsgDecoder decoder;
  elroy_common_msg::MessageDecoderResult message_decoder_result;

  // 2.
  {{namespace}}::{{msg_uut}}Message msg;

  const size_t kBufLen = msg.GetPackedSize();
  auto buf_vec = std::vector<uint8_t>(kBufLen);
  uint8_t* buf = buf_vec.data();
  
  // 3.
  size_t bytes_packed = msg.Pack(buf, kBufLen);
  (void) bytes_packed;

  // 4-5a
  {
    const size_t kBufLenWithoutCrc = msg.GetPackedSizeWithoutCrc();
    auto buf_wo_crc_vec = std::vector<uint8_t>(kBufLen);
    uint8_t* buf_without_crc = buf_wo_crc_vec.data();

    // 4.
    EXPECT_EQ(kBufLenWithoutCrc, kBufLen - elroy_common_msg::BusObjectMessage::kSizeOfCrcInBytes_);

    // 5.
    size_t bytes_packed_without_crc = msg.PackWithoutCrc(buf_without_crc, kBufLenWithoutCrc);

    for (size_t i = 0; i < kBufLen; i++) {
      if (i >= kBufLenWithoutCrc) {
        EXPECT_EQ(0, buf_without_crc[i]);
      } else {
        EXPECT_EQ(buf_without_crc[i], buf[i]);
      }
    }

    // 5a.
    EXPECT_EQ(bytes_packed_without_crc, kBufLenWithoutCrc);
  }

  // 6.
  size_t bytes_unpacked = msg.Unpack(buf, kBufLen);

  // 7-7a 
  {
    // 7.
    {{namespace}}::{{msg_uut}}Message msg_no_crc;
    size_t bytes_unpacked_without_crc = msg_no_crc.UnpackWithoutCrc(buf, kBufLen);
    EXPECT_EQ(bytes_unpacked_without_crc, bytes_unpacked - elroy_common_msg::BusObjectMessage::kSizeOfCrcInBytes_);

    // 7a.
    EXPECT_EQ(static_cast<uint32_t>(0), msg_no_crc.GetLatestUnpackedCrc());
  }

  size_t bytes_processed = 0;
  bool did_decode = false;

  // validate no message was handled prior to decoding
  EXPECT_EQ(static_cast<uint32_t>(0), handler.message_handle_counter_[static_cast<uint8_t>(msg.GetMessageId())]);

  // 8.
  did_decode = decoder.Decode(buf, kBufLen, handler, bytes_processed, message_decoder_result);

  // validate that msg was decoded
  EXPECT_TRUE(did_decode);

  // 8a.
  EXPECT_EQ(elroy_common_msg::MessageDecoderResult::SuccessfullyDecoded, message_decoder_result);

  // 9.
  EXPECT_EQ(bytes_processed, kBufLen);

  // 10.
  EXPECT_EQ(static_cast<uint32_t>(1), handler.message_handle_counter_[static_cast<uint8_t>(msg.GetMessageId())]);

  /// 11.
  for (uint32_t i = 0; i < TestHandler::kMessageHandleCounterArraySize_; i++) {
    /// skip the message under test
    if (i == static_cast<uint32_t>(msg.GetMessageId())) {
      continue;
    }
    EXPECT_EQ(static_cast<uint32_t>(0), handler.message_handle_counter_[i]);
  }
}

TEST(MsgHandlingUt, {{msg_uut}}BadDecode) {
  TestHandler handler;
  elroy_common_msg::MsgDecoder decoder;
  elroy_common_msg::MessageDecoderResult message_decoder_result;
  {{namespace}}::{{msg_uut}}Message msg;

  const size_t kBufLen = msg.GetPackedSize();
  auto buf_vec = std::vector<uint8_t>(kBufLen);
  uint8_t* buf = buf_vec.data();

  msg.Pack(buf, kBufLen);

  size_t bytes_processed = 0;
  const size_t kZero = 0;
  bool did_decode = false;

  /// 5. Decode with only 1 byte
  {
    did_decode = decoder.Decode(buf, 1, handler, bytes_processed, message_decoder_result);

    EXPECT_FALSE(did_decode);
    EXPECT_EQ(elroy_common_msg::MessageDecoderResult::NotEnoughBytesToDecodeMessageId, message_decoder_result);
    EXPECT_EQ(kZero, bytes_processed);
    EXPECT_EQ(static_cast<uint32_t>(0), handler.message_handle_counter_[static_cast<uint8_t>(msg.GetMessageId())]);
  }

  /// 6. Decodes with only 23 bytes (message ID)
  {
    /// failed decode with 2 bytes, expect bytes_processed = 2
    did_decode = decoder.Decode(buf, sizeof(elroy_common_msg::MessageId), handler, bytes_processed, message_decoder_result);

    EXPECT_FALSE(did_decode);
    EXPECT_EQ(sizeof(elroy_common_msg::MessageId), bytes_processed);
    EXPECT_EQ(static_cast<uint32_t>(0), handler.message_handle_counter_[static_cast<uint8_t>(msg.GetMessageId())]);
  }

  /// 7. Decodes < kBufLen
  {
    /// failed decode with < kBufLen, expect bytes_processed = 2
    did_decode = decoder.Decode(buf, kBufLen - 1, handler, bytes_processed, message_decoder_result);

    EXPECT_FALSE(did_decode);
    EXPECT_EQ(elroy_common_msg::MessageDecoderResult::BufLenIsLessThanPackedSize, message_decoder_result);
    EXPECT_EQ(sizeof(elroy_common_msg::MessageId), bytes_processed);
    EXPECT_EQ(static_cast<uint32_t>(0), handler.message_handle_counter_[static_cast<uint8_t>(msg.GetMessageId())]);
  }

  /// 8. Decode w/ invalid CRC
  {
    // save off crc
    uint8_t crc = buf[kBufLen - 1];

    // invalidate crc
    buf[kBufLen-1]++;

    did_decode = decoder.Decode(buf, kBufLen, handler, bytes_processed, message_decoder_result);

    EXPECT_FALSE(did_decode);
    EXPECT_EQ(elroy_common_msg::MessageDecoderResult::InvalidCrc, message_decoder_result);

    // put crc back
    buf[kBufLen-1] = crc;
  }

  /// 9. Decode w/ invalid Message Id
  {
    /// save off id
    uint8_t msg_id = buf[0];

    // set msg id to 0, invalid
    buf[0] = 0; 

    did_decode = decoder.Decode(buf, kBufLen - 1, handler, bytes_processed, message_decoder_result);

    EXPECT_FALSE(did_decode);
    EXPECT_EQ(elroy_common_msg::MessageDecoderResult::InvalidMessageId, message_decoder_result);

    // put id back
    buf[0] = msg_id;
  }
  
  {
    /// good decode
    did_decode = decoder.Decode(buf, kBufLen, handler, bytes_processed, message_decoder_result);

    EXPECT_TRUE(did_decode);
    EXPECT_EQ(elroy_common_msg::MessageDecoderResult::SuccessfullyDecoded, message_decoder_result);
    EXPECT_EQ(kBufLen, bytes_processed);
    EXPECT_EQ(static_cast<uint32_t>(1), handler.message_handle_counter_[static_cast<uint8_t>(msg.GetMessageId())]);
  }
}

{% endfor %}
