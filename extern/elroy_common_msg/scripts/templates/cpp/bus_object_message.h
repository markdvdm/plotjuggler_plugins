/// This file was autogenerated by elroy_common_msg, do not modify
/// @copyright Copyright 2022 Elroy Air Inc. All rights reserved.
/// @author elroy_common_msg autogen

#ifndef INCLUDE_ELROY_COMMON_MSG_COMMON_BUS_OBJECT_MESSAGE_H_
#define INCLUDE_ELROY_COMMON_MSG_COMMON_BUS_OBJECT_MESSAGE_H_

#include <cassert>
#include <cstddef>
#include <cstdint>

#include "elroy_common_msg/crc/c_crc_calculator.h"
#include "elroy_common_msg/enums/message_id.h"
#include "msg_packing_util/msg_packing_util.h"

// Forward Declaration
class IMsgHandler;

namespace elroy_common_msg {

static_assert(sizeof(bool) == 1, "elroy_common_msg expects sizeof(bool) to be 1");

class BusObjectMessage {
 public:
  static constexpr size_t kSizeOfCrcInBytes_ = sizeof(uint32_t);

  /// @brief Exposes public API to get MessageId
  /// @return ID associated with the specific instance of
  ///         BusObjectMessage
  constexpr MessageId GetMessageId() const { return id_; }

  /// @brief Returns the encoded size of this message without a CRC
  /// @return the encoded size of this message without a crc
  virtual size_t GetPackedSizeWithoutCrc(void) const noexcept = 0;

  /// @brief Packs this message into an array without a crc
  /// @note @see Pack() api, with use of GetPackedSize replaced with
  ///       GetPackedSizeWithoutCrc
  virtual size_t PackWithoutCrc(uint8_t *dest, size_t dest_size) const noexcept = 0;

  /// @brief Unpacks this message from an array without a crc
  /// @note @see Unpack() api, with use of GetPackedSize()
  ///       replaced with GetPackedSizeWithoutCrc()
  virtual size_t UnpackWithoutCrc(const uint8_t *src, size_t src_size) noexcept = 0;

  /// @brief Returns the encoded size of this message with a CRC
  /// @return the encoded size of this message with a crc
  size_t GetPackedSize(void) const noexcept { return GetPackedSizeWithoutCrc() + kSizeOfCrcInBytes_; }

  /// @brief Packs this message into an array with a CRC
  /// @note all encoding is little endian
  /// @param[out] dest array to destination array
  /// @param[in] dest_size size of dest array, needs to
  ///            be >= BusObject.GetPackedSize()
  /// @note dest_size is included as a contract to keep
  ///       the calling code honest
  /// @return number of bytes encoded. Will equal
  ///         GetPackedSize() and be <= dest_size
  size_t Pack(uint8_t *dest, size_t dest_size) const noexcept {
    assert(dest_size >= GetPackedSize());
    size_t bytes_packed = 0;
    bytes_packed = PackWithoutCrc(dest, dest_size);
    const uint32_t crc = CCrcCalculator::CalculateCrc(dest, GetPackedSize());
    bytes_packed += elroy_common_msg::MsgPackingUtil::Pack(&dest[bytes_packed], crc);
    (void)dest;
    (void)dest_size;
    return bytes_packed;
  }
  /// @brief Unpacks this message from an array with a crc
  /// @note all decoding is little endian
  /// @param[in] src src array
  /// @param[in] src_size size of the src array, needs to
  ///            be >= BusObject.GetPackedSize()
  /// @note src_size is included as a contract to keep the
  ///       calling code honest
  /// @return number of bytes decoded. Will equal
  ///         GetPackedSize() and be <= src_size
  size_t Unpack(const uint8_t *src, size_t src_size) noexcept {
    assert(src_size >= GetPackedSize());
    size_t bytes_unpacked = 0;
    bytes_unpacked = UnpackWithoutCrc(src, src_size);
    bytes_unpacked += elroy_common_msg::MsgPackingUtil::Unpack(latest_unpacked_crc_, &src[bytes_unpacked]);
    (void)src;
    (void)src_size;
    return bytes_unpacked;
  }

  /// @brief Exposes public API to get Timestamp
  /// @return Timestamp associated with the specific instance of
  ///         BusObjectMessage
  int64_t GetTimestampNs() const { return write_timestamp_ns_; }

  /// @brief Exposes public API to set message timestamp
  /// @param[in] timestamp time at which this message is written
  virtual void SetTimestampNs(const int64_t timestamp) noexcept { write_timestamp_ns_ = timestamp; }

  /// @brief returns the latest unpacked crc
  /// @note internal data member initialized to zero, will return
  ///       zero if nothing has been unpacked
  /// @return latest unpacked crc, 0 if nothing has been unpacked
  uint32_t GetLatestUnpackedCrc(void) const noexcept { return latest_unpacked_crc_; }

 protected:
  /// @brief Returns the encoded size of this message
  /// @note Called from derivced class ::GetPackedSize()
  /// @return the encoded size of this message
  virtual size_t do_getPackedSize(void) const noexcept { return sizeof(id_) + sizeof(write_timestamp_ns_); }

  /// @brief Packs this message into an array
  /// @note Called from derived class ::Pack
  /// @note all encoding is little endian
  /// @param[out] dest array to destination array
  /// @param[in] dest_size size of dest array, needs to
  ///            be >= BusObject.GetPackedSize()
  /// @note dest_size is included as a contract to keep
  ///       the calling code honest
  /// @return number of bytes encoded. Will equal
  ///         GetPackedSize() and be <= dest_size
  virtual size_t do_pack(uint8_t *dest, size_t dest_size) const noexcept {
    assert(dest_size >= do_getPackedSize());
    size_t bytes_packed = 0;
    bytes_packed += elroy_common_msg::MsgPackingUtil::Pack(&dest[bytes_packed], id_);
    bytes_packed += elroy_common_msg::MsgPackingUtil::Pack(&dest[bytes_packed], write_timestamp_ns_);
    (void)dest_size;
    return bytes_packed;
  }

  /// @brief Unpacks this message from an array
  /// @note Called from derived class ::Unpack
  /// @note all decoding is little endian
  /// @param[in] src src array
  /// @param[in] src_size size of the src array, needs to
  ///            be >= BusObject.GetPackedSize()
  /// @note src_size is included as a contract to keep the
  ///       calling code honest
  /// @return number of bytes decoded. Will equal
  ///         GetPackedSize() and be <= src_size
  virtual size_t do_unpack(const uint8_t *src, size_t src_size) noexcept {
    assert(src_size >= do_getPackedSize());
    size_t bytes_unpacked = 0;
    bytes_unpacked += elroy_common_msg::MsgPackingUtil::Unpack(id_, &src[bytes_unpacked]);
    bytes_unpacked += elroy_common_msg::MsgPackingUtil::Unpack(write_timestamp_ns_, &src[bytes_unpacked]);
    (void)src_size;
    return bytes_unpacked;
  }

  /// @brief remove default constructor
  BusObjectMessage() = delete;

  /// @brief copy constructor
  BusObjectMessage(const BusObjectMessage &src) : id_{src.id_}, write_timestamp_ns_{src.write_timestamp_ns_} {}

  /// @brief default assingment operator
  BusObjectMessage &operator=(const BusObjectMessage &src) = default;

  /// @brief default destructor
  virtual ~BusObjectMessage() = default;

  /// @brief Protected constructor to pass down id
  /// @param[in] Message ID
  explicit BusObjectMessage(const MessageId id) : id_(id), write_timestamp_ns_{} {}

  MessageId id_ = MessageId::Unknown;
  int64_t write_timestamp_ns_ = 0;
  uint32_t latest_unpacked_crc_ = 0;
};

}  // namespace elroy_common_msg

#endif  //  INCLUDE_ELROY_COMMON_MSG_COMMON_BUS_OBJECT_H_
