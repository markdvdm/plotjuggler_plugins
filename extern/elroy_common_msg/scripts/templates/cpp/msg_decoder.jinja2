/// @copyright Copyright 2022 Elroy Air Inc. All rights reserved.
/// @author elroy_common_msg autogeneration

#ifndef ELROY_COMMON_MSG_MSG_HANDLING_MSG_DECODER_H_
#define ELROY_COMMON_MSG_MSG_HANDLING_MSG_DECODER_H_

#include "elroy_common_msg/crc/c_crc_calculator.h"
#include "elroy_common_msg/enums/message_decoder_result.h"
#include "elroy_common_msg/msg_handling/msg_handler.h"
#include "msg_packing_util/msg_packing_util.h"
#include <variant>
#include <map>

namespace elroy_common_msg {

class MsgDecoder {
 public:
  /// @brief Constructs this msg stream decoder
  /// @note nothing to be done in construction
  MsgDecoder() {}

  /// @brief destructor
  virtual ~MsgDecoder() = default;

  /// @brief Attempts to decode a message from buf. If a msg
  ///        is successfully decoded, the handlers 'Handle()'
  ///        function is envoked
  /// @note Intentionally not const, allows for MsgHandler
  ///       to change state on its internal computations
  /// @note Decode occurs as follows:
  ///         1. If `buf_len` is at least sizeof(MessageId),
  ///            move to step 2, else return false
  ///         2. Unpack Message ID from buffer
  ///         3. Switch-case on message ID
  ///             a. For each message, if buf_len is >=
  ///                msg.GetPackedSize(), invoke Unpack,
  ///                else return false
  ///             b. if MessageId does not match the set of
  ///                ID's, return false
  /// @note Simple return of bool does not provide sufficient
  ///       insight into why the decode fail. At a later date
  ///       this will be updated with common error codes
  /// @param[in] buf pointer to serialized array
  /// @param[in] buf_len the number of bytes in buf_len
  /// @param[in] handler reference to appropriate message handler
  /// @param[out] bytes_processed the number of bytes processed on
  ///             this call to `Decode`
  /// @param[out] message_decoder_result will bet set to
  ///             MessageDecoderResult::NotEnoughBytesToDecodeMessageId when
  ///             buf_len < sizeof(elroy_common_msg::MessageId); i.e.
  ///             cannot decode the message id
  /// @param[out] message_decoder_result will be set to
  ///             MessageDecoderResult::InvalidMessageId when
  ///             an invalid message is received/deocded from buf[0-1]
  /// @param[out] message_decoder_result will be set to
  ///             MessageDecoderResult::BufLenIsLessThanPackedSize if
  ///             a valid Message ID is decoded but buf_len is less
  ///             than that message's PackedSize()
  /// @param[out] message_decoder_result will be set to
  ///             MessageDecoderResult::InvalidCrc if a valid Message Id
  ///             is decoded, buf_len <= that message's PackedSize(), but
  ///             the calculated CRC does not match the crc in buf
  /// @param[out] message_decoder_result will be set to
  ///             MessageDecoderResult::SuccessfullyDecoded when
  ///             a message has been successfully decoded. The handler's
  ///             `Handle` function will also have been invoked
  /// @post If a message is decoded, the parameter handler will
  ///       be invoked for that specific message. bytes_processed
  ///       will be updated with number of bytes processed.
  /// @return true if the message was decoded and handler invoked,
  ///         false otherwise
  virtual bool Decode(const uint8_t * const buf, const size_t buf_len,
    elroy_common_msg::IMsgHandler& handler,
    size_t& bytes_processed, MessageDecoderResult& message_decoder_result) noexcept {
    assert(nullptr != buf);
    assert(0 < buf_len);

    MessageId id;
    bool ret = false;
    bytes_processed = 0;
    
    message_decoder_result = MessageDecoderResult::SuccessfullyDecoded;

    // decoding can begin when buf_len is at least
    if (sizeof(MessageId) <= buf_len) {
      bytes_processed = sizeof(MessageId);
      elroy_common_msg::MsgPackingUtil::Unpack(id, buf);

      switch (id) {
        {% for msg in msg_handling.msgs %}
        case MessageId::{{msg.class.name}}:
        {
          elroy_common_msg::
          {%- if msg.class.namespace is defined -%}{{ msg.class.namespace }}::{%- endif -%}
          {{- msg.class.name -}}Message msg;
          if (msg.GetPackedSize() <= buf_len) {
            if (true == CCrcCalculator::CalculateAndCompareCrc(buf, msg.GetPackedSize())) {
              bytes_processed = msg.GetPackedSize();
              msg.Unpack(buf, buf_len);
              handler.Handle(msg);
              ret = true;
            } else {
              message_decoder_result = MessageDecoderResult::InvalidCrc;
            }
          } else {
            message_decoder_result = MessageDecoderResult::BufLenIsLessThanPackedSize;
          }
          break;
        }
        {% endfor %}
        default:
          message_decoder_result = MessageDecoderResult::InvalidMessageId;
          break;
      }
    } else {
      message_decoder_result = MessageDecoderResult::NotEnoughBytesToDecodeMessageId;
    }

    return ret;
  }


  virtual bool DecodeAsMap(const uint8_t * const buf, const size_t buf_len,
    size_t& bytes_processed, std::unordered_map<std::string, std::variant<std::string, double, bool>> &map, MessageDecoderResult& message_decoder_result, const std::string& delim=".") const noexcept{
    assert(nullptr != buf);
    assert(0 < buf_len);

    MessageId id;
    bool ret = false;
    bytes_processed = 0;
    
    message_decoder_result = MessageDecoderResult::SuccessfullyDecoded;

    // decoding can begin when buf_len is at least
    if (sizeof(MessageId) <= buf_len) {
      bytes_processed = sizeof(MessageId);
      elroy_common_msg::MsgPackingUtil::Unpack(id, buf);

      switch (id) {
        {% for msg in msg_handling.msgs %}
        case MessageId::{{msg.class.name}}:
        {
          elroy_common_msg::
          {%- if msg.class.namespace is defined -%}{{ msg.class.namespace }}::{%- endif -%}
          {{- msg.class.name -}}Message msg;
          if (msg.GetPackedSize() <= buf_len) {
            if (true == CCrcCalculator::CalculateAndCompareCrc(buf, msg.GetPackedSize())) {
              bytes_processed = msg.GetPackedSize();
              msg.Unpack(buf, buf_len);
              ret = msg.ReadAsMap(map, "{{msg.class.name}}", delim);
            } else {
              message_decoder_result = MessageDecoderResult::InvalidCrc;
            }
          } else {
            message_decoder_result = MessageDecoderResult::BufLenIsLessThanPackedSize;
          }
          break;
        }
        {% endfor %}
        default:
          message_decoder_result = MessageDecoderResult::InvalidMessageId;
          break;
      }
    } else {
      message_decoder_result = MessageDecoderResult::NotEnoughBytesToDecodeMessageId;
    }

    return ret;
  }


  /// @brief Const correct version of Decode()
  virtual bool Decode(const uint8_t * const buf, const size_t buf_len,
    const elroy_common_msg::IMsgHandler& handler,
    size_t& bytes_processed, MessageDecoderResult& message_decoder_result) const noexcept {
    assert(nullptr != buf);
    assert(0 < buf_len);

    MessageId id;
    bool ret = false;
    bytes_processed = 0;

    message_decoder_result = MessageDecoderResult::SuccessfullyDecoded;

    // decoding can begin when buf_len is at least
    if (sizeof(MessageId) <= buf_len) {
      bytes_processed = sizeof(MessageId);
      elroy_common_msg::MsgPackingUtil::Unpack(id, buf);

      switch (id) {
        {% for msg in msg_handling.msgs %}
        case MessageId::{{msg.class.name}}:
        {
          elroy_common_msg::
          {%- if msg.class.namespace is defined -%}{{ msg.class.namespace }}::{%- endif -%}
          {{- msg.class.name -}}Message msg;
          if (msg.GetPackedSize() <= buf_len) {
            if (true == CCrcCalculator::CalculateAndCompareCrc(buf, msg.GetPackedSize())) {
              bytes_processed = msg.GetPackedSize();
              msg.Unpack(buf, buf_len);
              handler.Handle(static_cast<const
                elroy_common_msg::
                {%- if msg.class.namespace is defined -%}{{ msg.class.namespace }}::{%- endif -%} 
                {{-msg.class.name-}}Message>(msg));
              ret = true;
            } else {
              message_decoder_result = MessageDecoderResult::InvalidCrc;
            }
          } else {
            message_decoder_result = MessageDecoderResult::BufLenIsLessThanPackedSize;
          }
          break;
        }
        {% endfor %}
        default:
          message_decoder_result = MessageDecoderResult::InvalidMessageId;
          break;
      }
    } else {
      message_decoder_result = MessageDecoderResult::NotEnoughBytesToDecodeMessageId;
    }

    return ret;
  }
};

}  // namespace elroy_common_msg

#endif  // ELROY_COMMON_MSG_MSG_HANDLING_MSG_DECODER_H_
