/// This file was autogenerated by elroy_common_msg, do not modify
/// @copyright Copyright 2022 Elroy Air Inc. All rights reserved.
/// @author elroy_common_msg autogen

#ifndef {{ enum.metadata.file.header.include_guard}}
#define {{ enum.metadata.file.header.include_guard }}

#include <cstddef>
#include <cstdint>

{% if "namespace" in enum %}
namespace elroy_common_msg::{{ enum.namespace }} {
{% else %}
namespace elroy_common_msg {
{% endif %}

enum class {{ enum.name }} : {{ enum.type }} {
  Unknown = 0,
  {% for enum in enum.list %}
  {{ enum }} = {{ loop.index }},
  {% if loop.last %}
  Count = {{ loop.index + 1 }}
  {% endif %}
  {% endfor %}
};

constexpr size_t {{ enum.name }}ArraySize() {
  return static_cast<size_t>(static_cast<{{ enum.type }}>({{ enum.name }}::Count) - 1);
}

constexpr bool InValidRange(const {{ enum.name }} &value) {
  return (static_cast<{{ enum.type }}>(value) > static_cast<{{ enum.type }}>({{ enum.name }}::Unknown)) &&
    (static_cast<{{ enum.type }}>(value) < static_cast<{{ enum.type }}>({{ enum.name }}::Count));
}

constexpr size_t EnumToArrayIndex(const {{ enum.name }} &value) {
  return static_cast<size_t>(value) - 1;
}

constexpr {{ enum.name }} ArrayIndexTo{{ enum.name }}(const size_t &value) {
  return static_cast<{{ enum.name }}>(value + 1);
}

constexpr const char* EnumToString(const {{ enum.name }} &value) {
  switch (value) {
    case {{ enum.name }}::Unknown:
      return "Unknown";
  {% for enum_identifier in enum.list %}
    case {{ enum.name }}::{{ enum_identifier }}:
      return "{{ enum_identifier }}";
  {% endfor %}
    case {{ enum.name }}::Count:
      return "Count";
    default:
      return "Undefined {{ enum.name }} identifier";
  }
}

{% if "brief_list" in enum %}
constexpr const char* EnumToBriefString(const {{ enum.name }} &value) {
  switch (value) {
    case {{ enum.name }}::Unknown:
      return "Unknown";
  {% for enum_identifier in enum.list %}
    case {{ enum.name }}::{{ enum_identifier }}:
      return "{{ enum.brief_list[loop.index0] }}";
  {% endfor %}
    case {{ enum.name }}::Count:
      return "Count";
    default:
      return "Undefined";
  }
}
{% endif %}

{% if "elaboration_list" in enum %}
constexpr const char* EnumToElaboratedString(const {{ enum.name }} &value) {
  switch (value) {
    case {{ enum.name }}::Unknown:
      return "Unknown";
  {% for enum_identifier in enum.list %}
    case {{ enum.name }}::{{ enum_identifier }}:
      return "{{ enum.elaboration_list[loop.index0] }}";
  {% endfor %}
    case {{ enum.name }}::Count:
      return "Count";
    default:
      return "Undefined {{ enum.name }} identifier";
  }
}
{% endif %}

} // namespace {% if "namespace" in enum %} {{enum.namespace}} {% else %}elroy_common_msg {% endif %}


#endif   // {{ enum.metadata.file.header.include_guard }}
